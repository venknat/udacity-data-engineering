import configparser

# CONFIG
config = configparser.ConfigParser()
config.read('dwh.cfg')

# DROP TABLES

staging_events_table_drop = "DROP TABLE IF EXISTS events_staging;"
staging_songs_table_drop = "DROP TABLE IF EXISTS songs_staging;"
songplay_table_drop = "DROP TABLE IF EXISTS songplays;"
user_table_drop = "DROP TABLE IF EXISTS users;"
song_table_drop = "DROP TABLE IF EXISTS songs;"
artist_table_drop = "DROP TABLE IF EXISTS artists;"
time_table_drop = "DROP TABLE IF EXISTS times;"

# CREATE TABLES

staging_events_table_create= ("""
    CREATE TABLE IF NOT EXISTS events_staging (
      artist varchar(1023),
      auth varchar(255),
      firstName varchar(255),
      gender varchar(10),
      itemInSession integer,
      lastName varchar(255),
      length decimal(7,2),
      level varchar(10),
      location varchar(255),
      method varchar(255),
      page varchar(255),
      registration double precision,
      sessionId integer,
      song varchar(1023),
      status integer,
      ts bigint,
      userAgent varchar(255),
      userId integer
    );
""")

# TODO: check if artist id and song id can have different lengths
# Also, what does num_songs mean here?  Is it the number of songs by the artist, total?
# A weird thing to put in json that's supposedly about one song.  But if the json is abount
# one song, why would I need to be told how many songs?
staging_songs_table_create = ("""
    CREATE TABLE IF NOT EXISTS songs_staging (
        artist_id varchar(25),
        artist_latitude double precision,
        artist_location varchar(1023),
        artist_longitude double precision,
        artist_name varchar(1023),
        duration decimal(7,2),
        num_songs integer,
        song_id varchar(25),
        title varchar(1023),
        year integer
    );
""")

# It is likely we will want to match a songplay with information from the associated time table;
# so it will be efficient to make sure that a given songplay record, and the times record corresponding
# to the time of the songplay, are in the same place.  To ensure this, distribute both based on the
# timestamp.
songplay_table_create = ("""
    CREATE TABLE IF NOT EXISTS songplays (
        songplay_id integer GENERATED BY DEFAULT AS IDENTITY (0,1),
        start_time bigint,
        user_id integer,
        level varchar(10),
        song_id varchar(25),
        artist_id varchar(25),
        session_id integer,
        location varchar(255),
        user_agent varchar(255),
        primary key(songplay_id),
        foreign key(song_id) references songs(song_id),
        foreign key(artist_id) references artists(artist_id),
        foreign key(user_id) references users(user_id),
        foreign key(start_time) references times(start_time)
    ) DISTKEY(start_time);
""")

user_table_create = ("""
    CREATE TABLE IF NOT EXISTS users (
        user_id integer,
        first_name varchar(255) NOT NULL,
        last_name varchar(255) NOT NULL,
        gender varchar(10),
        level varchar(10),
        primary key(user_id)
    ) DISTSTYLE ALL;
""")

song_table_create = ("""
    CREATE TABLE IF NOT EXISTS songs (
        song_id varchar(25),
        title varchar(1023) NOT NULL,
        artist_id varchar(25),
        year integer,
        duration decimal(7,2),
        primary key(song_id),
        foreign key(artist_id) references artists(artist_id)
    ) DISTSTYLE ALL;
""")

artist_table_create = ("""
    CREATE TABLE IF NOT EXISTS artists (
        artist_id varchar(25),
        name varchar(255) NOT NULL,
        location varchar(50),
        latitude double precision,
        longitude double precision,
        primary key(artist_id)
    ) DISTSTYLE ALL;
""")

time_table_create = ("""
    CREATE TABLE IF NOT EXISTS times (
        start_time bigint,
        hour integer NOT NULL,
        day integer NOT NULL,
        week integer NOT NULL,
        month integer NOT NULL,
        year integer NOT NULL,
        weekday integer NOT NULL,
        primary key(start_time)
    ) DISTKEY(start_time);
""")


# STAGING TABLES
staging_events_copy = """
        COPY events_staging FROM {}
        iam_role '{}'
        format as json {};
    """.format(config.get('S3', 'LOG_DATA'), config.get('IAM_ROLE', 'ARN'), config.get('S3', 'LOG_JSONPATH'))


staging_songs_copy = """
        COPY songs_staging from {}
        iam_role '{}'
        FORMAT AS json 'auto ignorecase'
        REGION 'us-west-2';
    """.format(config.get('S3', 'SONG_DATA'), config.get('IAM_ROLE', 'ARN'))

# FINAL TABLES

songplay_table_insert = ("""
    INSERT INTO songplays (start_time, user_id, level, song_id, artist_id, session_id, location, user_agent)
    (
        SELECT
            e.ts,
            e.userId,
            e.level,
            s.song_id,
            s.artist_id,
            e.sessionId,
            e.location,
            e.userAgent
        FROM events_staging e
        LEFT JOIN songs_staging s ON s.title = e.song AND s.artist_name = e.artist AND s.duration = e.length
        WHERE e.page='NextSong'
    );
""")

# Since it will be common for the same user to show up multiple times, it would be nice
# to have a way to do a merge (i.e. if a user id exists, and some values well null in
# one record, make sure a non-null is chosen from another record if available), but
# I'm not sure how to accomplish that here.  Perhaps a GROUP BY would be useful,
# but that might get really complicated to get right.
user_table_insert = ("""
    INSERT INTO users (user_id, first_name, last_name, gender, level)
    (
        SELECT DISTINCT userId, firstName, lastName, gender, level
        FROM events_staging
        WHERE page='NextSong' AND userId IS NOT NULL
    );
""")

song_table_insert = ("""
    INSERT INTO songs (song_id, title, artist_id, year, duration)
    (
        SELECT song_id, title, artist_id, NULLIF(year, 0), duration FROM songs_staging
    );
""")

artist_table_insert = ("""
    INSERT INTO artists (artist_id, name, location, latitude, longitude)
    (
        SELECT artist_id, artist_name, artist_location, artist_latitude, artist_longitude
        FROM songs_staging
        WHERE artist_id IS NOT NULL
    );
""")

# NOTE: To avoid repeated (timestamp 'epoch' + ...) statements, would a subquery make sense
# here?  Would that slow things down?
time_table_insert = ("""
    INSERT INTO times (start_time, hour, day, week, month, year, weekday)
    (
        SELECT
            ts,
            extract(hour from (timestamp 'epoch' + ts/1000 * interval '1 second')),
            extract(day from (timestamp 'epoch' + ts/1000 * interval '1 second')),
            extract(week from (timestamp 'epoch' + ts/1000 * interval '1 second')),
            extract(month from (timestamp 'epoch' + ts/1000 * interval '1 second')),
            extract(year from (timestamp 'epoch' + ts/1000 * interval '1 second')),
            extract(weekday from (timestamp 'epoch' + ts/1000 * interval '1 second'))
        FROM events_staging WHERE ts IS NOT NULL AND page='NextSong'
    );
""")

# QUERY LISTS
create_table_queries = [staging_events_table_create, staging_songs_table_create, artist_table_create, time_table_create,
                        user_table_create, song_table_create, songplay_table_create]
drop_table_queries = [staging_events_table_drop, staging_songs_table_drop, songplay_table_drop, user_table_drop,
                      song_table_drop, artist_table_drop, time_table_drop]
copy_table_queries = [staging_events_copy, staging_songs_copy]
insert_table_queries = [artist_table_insert, time_table_insert, song_table_insert, user_table_insert,
                        songplay_table_insert]
